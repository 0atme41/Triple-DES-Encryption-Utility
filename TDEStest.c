/** 
    @file TDEStest.c
    @author dbsturgi
    Unit tests for the Triple-DES implementation.
*/

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include "TDES.h"
#include "TDESinternal.h"

/** Number of tests we should have, if they're all turned on. */
#define EXPECTED_TOTAL 73

/** Total number or tests we tried. */
static int totalTests = 0;

/** Number of test cases passed. */
static int passedTests = 0;

/** Macro to check the condition on a test case, keep counts of
    passed/failed tests and report a message if the test fails. */
#define TestCase( conditional ) {\
  totalTests += 1; \
  if ( conditional ) { \
    passedTests += 1; \
  } else { \
    printf( "**** Failed unit test on line %d of %s\n", __LINE__, __FILE__ );    \
  } \
}

/** Return true if A and B contain the same sequence of n bytes. */
bool cmpBytes( byte const A[], byte const B[], int n )
{
  for ( int i = 0; i < n; i++ )
    if ( A[ i ] != B[ i ] )
      return false;
  return true;
}

int main()
{
  // As you finish parts of your implementation, move this directive
  // down past the blocks of code below.  That will enable tests of
  // various functions you're expected to implement.
  
  ////////////////////////////////////////////////////////////////////////
  // Test getBit()

  {
    byte data[] = { 0xFF, 0x00, 0x55, 0xAA };

    // Check some positions in this array of bytes.
    TestCase( getBit( data, 1 ) == 1 );
    TestCase( getBit( data, 8 ) == 1 );
    TestCase( getBit( data, 9 ) == 0 );
    TestCase( getBit( data, 16 ) == 0 );
    TestCase( getBit( data, 17 ) == 0 );
    TestCase( getBit( data, 18 ) == 1 );
    TestCase( getBit( data, 31 ) == 1 );
    TestCase( getBit( data, 32 ) == 0 );
  }

  ////////////////////////////////////////////////////////////////////////
  // Test setBit()

  {
    byte data[] = { 0xFF, 0x00, 0x55, 0xAA };

    // Flip the first bit to 0.
    putBit( data, 1, 0 );
    TestCase( data[ 0 ] == 0x7F );
    
    // Flip the 8th bit to 0.
    putBit( data, 8, 0 );
    TestCase( data[ 0 ] == 0x7E );
    
    // No change to bit 5.
    putBit( data, 5, 1 );
    TestCase( data[ 0 ] == 0x7E );

    // Set bits number 9 and 16
    putBit( data, 9, 1 );
    putBit( data, 16, 1 );
    TestCase( data[ 1 ] == 0x81 );
    
    // Clear bit 17 and set 19 (no change)
    putBit( data, 17, 0 );
    putBit( data, 18, 1 );
    TestCase( data[ 2 ] == 0x55 );
    
    // Clear bit 31 and set 32
    putBit( data, 31, 0 );
    putBit( data, 32, 1 );
    TestCase( data[ 3 ] == 0xA9 );
  }
  
  ////////////////////////////////////////////////////////////////////////
  // Test permute()

  {
    byte input[ 2 ] = { 0xBC, 0xD6 };
    int perm[ 16 ] = { 7, 14, 12, 13, 1, 6, 11, 8, 4, 16, 15, 10, 3, 5, 9, 2 };
    byte output[ 2];

    permute( output, input, perm, 16 );
    TestCase( output[ 0 ] == 0x6C );
    TestCase( output[ 1 ] == 0xBE );
  }

  {
    // Try selecting a subset of the bits.
    byte input[ 2 ] = { 0xFF, 0x00 };
    int perm[ 16 ] = { 9, 10, 11, 12, 1, 2, 3, 4, 7, 8 };
    byte output[ 2] = { 0xFF, 0xFF };

    permute( output, input, perm, 10 );
    TestCase( output[ 0 ] == 0x0F );

    // Make sure the last byte gets filled in with zeros.
    TestCase( output[ 1 ] == 0xC0 );
  }

  ////////////////////////////////////////////////////////////////////////
  // Test generateSubkeys()

  {
    // Same example shown in the DES Algorithm Illustrated article.
    byte key[ BLOCK_BYTES ] = { 0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1 };

    byte K[ ROUND_COUNT ][ SUBKEY_BYTES ];
    generateSubkeys( K, key );

    TestCase( cmpBytes( K[1], (byte []){ 0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72 }, 6 ) );
    TestCase( cmpBytes( K[2], (byte []){ 0x79, 0xAE, 0xD9, 0xDB, 0xC9, 0xE5 }, 6 ) );
    TestCase( cmpBytes( K[3], (byte []){ 0x55, 0xFC, 0x8A, 0x42, 0xCF, 0x99 }, 6 ) );
    TestCase( cmpBytes( K[4], (byte []){ 0x72, 0xAD, 0xD6, 0xDB, 0x35, 0x1D }, 6 ) );
    TestCase( cmpBytes( K[5], (byte []){ 0x7C, 0xEC, 0x07, 0xEB, 0x53, 0xA8 }, 6 ) );
    TestCase( cmpBytes( K[6], (byte []){ 0x63, 0xA5, 0x3E, 0x50, 0x7B, 0x2F }, 6 ) );
    TestCase( cmpBytes( K[7], (byte []){ 0xEC, 0x84, 0xB7, 0xF6, 0x18, 0xBC }, 6 ) );
    TestCase( cmpBytes( K[8], (byte []){ 0xF7, 0x8A, 0x3A, 0xC1, 0x3B, 0xFB }, 6 ) );
    TestCase( cmpBytes( K[9], (byte []){ 0xE0, 0xDB, 0xEB, 0xED, 0xE7, 0x81 }, 6 ) );
    TestCase( cmpBytes( K[10], (byte []){ 0xB1, 0xF3, 0x47, 0xBA, 0x46, 0x4F }, 6 ) );
    TestCase( cmpBytes( K[11], (byte []){ 0x21, 0x5F, 0xD3, 0xDE, 0xD3, 0x86 }, 6 ) );
    TestCase( cmpBytes( K[12], (byte []){ 0x75, 0x71, 0xF5, 0x94, 0x67, 0xE9 }, 6 ) );
    TestCase( cmpBytes( K[13], (byte []){ 0x97, 0xC5, 0xD1, 0xFA, 0xBA, 0x41 }, 6 ) );
    TestCase( cmpBytes( K[14], (byte []){ 0x5F, 0x43, 0xB7, 0xF2, 0xE7, 0x3A }, 6 ) );
    TestCase( cmpBytes( K[15], (byte []){ 0xBF, 0x91, 0x8D, 0x3D, 0x3F, 0x0A }, 6 ) );
    TestCase( cmpBytes( K[16], (byte []){ 0xCB, 0x3D, 0x8B, 0x0E, 0x17, 0xF5 }, 6 ) );
  }
  
  {
    // First encryption key used in test 01
    byte key[ BLOCK_BYTES ] = { 0x54, 0x68, 0x69, 0x73, 0x20, 0x6B, 0x65, 0x79 };

    byte K[ ROUND_COUNT ][ SUBKEY_BYTES ];
    generateSubkeys( K, key );

    TestCase( cmpBytes( K[1], (byte[]){ 0xD0, 0xB6, 0x66, 0x56, 0x0C, 0x29 }, 6 ) );
    TestCase( cmpBytes( K[2], (byte[]){ 0xE0, 0xAE, 0x76, 0x20, 0xD4, 0x16 }, 6 ) );
    TestCase( cmpBytes( K[3], (byte[]){ 0xE4, 0xF6, 0x32, 0xCD, 0x04, 0xA2 }, 6 ) );
    TestCase( cmpBytes( K[4], (byte[]){ 0xE6, 0x97, 0x72, 0x8C, 0x4A, 0x49 }, 6 ) );
    TestCase( cmpBytes( K[5], (byte[]){ 0xEE, 0xD2, 0x53, 0x12, 0xD2, 0x54 }, 6 ) );
    TestCase( cmpBytes( K[6], (byte[]){ 0x2F, 0xD3, 0x5A, 0x91, 0x85, 0xA0 }, 6 ) );
    TestCase( cmpBytes( K[7], (byte[]){ 0x2E, 0x51, 0xDB, 0x88, 0x2E, 0x01 }, 6 ) );
    TestCase( cmpBytes( K[8], (byte[]){ 0x3F, 0x49, 0x59, 0x7A, 0x62, 0x14 }, 6 ) );
    TestCase( cmpBytes( K[9], (byte[]){ 0x1F, 0x59, 0xD9, 0x82, 0x88, 0x27 }, 6 ) );
    TestCase( cmpBytes( K[10], (byte[]){ 0x1F, 0x61, 0xCD, 0x06, 0x2F, 0x94 }, 6 ) );
    TestCase( cmpBytes( K[11], (byte[]){ 0x1B, 0x4D, 0x8D, 0x39, 0x01, 0xD1 }, 6 ) );
    TestCase( cmpBytes( K[12], (byte[]){ 0x59, 0x29, 0xAD, 0x43, 0xC0, 0x03 }, 6 ) );
    TestCase( cmpBytes( K[13], (byte[]){ 0x91, 0xAC, 0xAD, 0x46, 0x25, 0x0C }, 6 ) );
    TestCase( cmpBytes( K[14], (byte[]){ 0xD1, 0x2E, 0xA6, 0xA8, 0x11, 0xCC }, 6 ) );
    TestCase( cmpBytes( K[15], (byte[]){ 0xF0, 0xBE, 0xA4, 0x40, 0xD2, 0xA3 }, 6 ) );
    TestCase( cmpBytes( K[16], (byte[]){ 0xE0, 0xBC, 0x26, 0x28, 0xE9, 0x48 }, 6 ) );
  }

  ////////////////////////////////////////////////////////////////////////
  // Test sBox()

  {
    byte B[ 6 ] = { 0x61, 0x17, 0xBA, 0x86, 0x65, 0x27 };
    byte output[ 1 ];

    sBox( output, B, 0 );
    TestCase( output[ 0 ] == 0x50 );
    sBox( output, B, 1 );
    TestCase( output[ 0 ] == 0xC0 );
    sBox( output, B, 2 );
    TestCase( output[ 0 ] == 0x80 );
    sBox( output, B, 3 );
    TestCase( output[ 0 ] == 0x20 );
    sBox( output, B, 4 );
    TestCase( output[ 0 ] == 0xB0 );
    sBox( output, B, 5 );
    TestCase( output[ 0 ] == 0x50 );
    sBox( output, B, 6 );
    TestCase( output[ 0 ] == 0x90 );
    sBox( output, B, 7 );
    TestCase( output[ 0 ] == 0x70 );
  }

  ////////////////////////////////////////////////////////////////////////
  // Test fFunction()

  {
    byte R[ 4 ] = { 0xF0, 0xAA, 0xF0, 0xAA };
    byte subkey[ 6 ] = { 0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72 };
    byte result[ 4 ];

    fFunction( result, R, subkey );
    
    TestCase( cmpBytes( result, (byte []){ 0x23, 0x4A, 0xA9, 0xBB }, 4 ) );
  } 

  ////////////////////////////////////////////////////////////////////////
  // Test encryptBlock()

  {
    // This should match the first block encryption in test 01
    byte K[ ROUND_COUNT ][ SUBKEY_BYTES ] = {
      {}, // First element not used.
      { 0xD0, 0xB6, 0x66, 0x56, 0x0C, 0x29 },
      { 0xE0, 0xAE, 0x76, 0x20, 0xD4, 0x16 },
      { 0xE4, 0xF6, 0x32, 0xCD, 0x04, 0xA2 },
      { 0xE6, 0x97, 0x72, 0x8C, 0x4A, 0x49 },
      { 0xEE, 0xD2, 0x53, 0x12, 0xD2, 0x54 },
      { 0x2F, 0xD3, 0x5A, 0x91, 0x85, 0xA0 },
      { 0x2E, 0x51, 0xDB, 0x88, 0x2E, 0x01 },
      { 0x3F, 0x49, 0x59, 0x7A, 0x62, 0x14 },
      { 0x1F, 0x59, 0xD9, 0x82, 0x88, 0x27 },
      { 0x1F, 0x61, 0xCD, 0x06, 0x2F, 0x94 },
      { 0x1B, 0x4D, 0x8D, 0x39, 0x01, 0xD1 },
      { 0x59, 0x29, 0xAD, 0x43, 0xC0, 0x03 },
      { 0x91, 0xAC, 0xAD, 0x46, 0x25, 0x0C },
      { 0xD1, 0x2E, 0xA6, 0xA8, 0x11, 0xCC },
      { 0xF0, 0xBE, 0xA4, 0x40, 0xD2, 0xA3 },
      { 0xE0, 0xBC, 0x26, 0x28, 0xE9, 0x48 }
    };
    byte block[] = { 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x0A, 0x01 };
    byte expected[] = { 0xB3, 0xEB, 0xA2, 0x74, 0x05, 0xA1, 0x42, 0x80 };

    encryptBlock( block, K );
    TestCase( cmpBytes( block, expected, sizeof( block ) ) );
  }

  {
    // This should match the last block encryption in test 01
    byte K[ ROUND_COUNT ][ SUBKEY_BYTES ] = {
      {}, // First element not used.
      { 0xE0, 0x3E, 0x06, 0x18, 0x69, 0x63 },
      { 0x60, 0x36, 0x26, 0x64, 0x49, 0x25 },
      { 0xE0, 0x94, 0x74, 0x82, 0x08, 0xDA },
      { 0xC4, 0xC2, 0x72, 0xC5, 0x93, 0x11 },
      { 0xA6, 0xD3, 0x32, 0x13, 0x06, 0x68 },
      { 0xAE, 0x13, 0x43, 0x58, 0x99, 0x04 },
      { 0x2B, 0x52, 0x59, 0x00, 0x64, 0xBC },
      { 0x0D, 0x51, 0xD8, 0x69, 0x38, 0x81 },
      { 0x17, 0x41, 0xD8, 0x2A, 0xA2, 0x31 },
      { 0x1E, 0x49, 0x91, 0xB3, 0x4D, 0x02 },
      { 0x1F, 0x29, 0x0D, 0x0C, 0x03, 0x12 },
      { 0x0B, 0x24, 0x8D, 0xD5, 0x60, 0x44 },
      { 0x59, 0x0C, 0xAC, 0x60, 0x82, 0xC8 },
      { 0xD0, 0xA8, 0xA8, 0x90, 0xB4, 0x0F },
      { 0x90, 0xAE, 0x26, 0x2E, 0x16, 0xA0 },
      { 0xB0, 0xAE, 0x06, 0x0A, 0x70, 0xA2 }
    };
    byte block[] = { 0x73, 0xF6, 0xCB, 0x51, 0x94, 0x27, 0xA6, 0xAC };
    byte expected[] = { 0x35, 0x80, 0x10, 0x52, 0x02, 0x61, 0x46, 0x5E };

    encryptBlock( block, K );
    TestCase( cmpBytes( block, expected, sizeof( block ) ) );
  }

  {
    // This should match the middle block encryption in test 11
    byte K[ ROUND_COUNT ][ SUBKEY_BYTES ] = {
      {}, // First element not used.
      { 0xF0, 0x3C, 0xE6, 0x28, 0x20, 0x4E },
      { 0x50, 0xBE, 0x76, 0x52, 0x05, 0x21 },
      { 0xE4, 0xFC, 0x76, 0x0A, 0x29, 0x08 },
      { 0xE6, 0xE7, 0x66, 0x60, 0x71, 0x10 },
      { 0xEA, 0xD7, 0x33, 0x61, 0x00, 0x2A },
      { 0xED, 0x93, 0x7B, 0xC4, 0x18, 0x0A },
      { 0xA7, 0xD2, 0xDB, 0x04, 0x12, 0x7C },
      { 0x3F, 0x5B, 0xD2, 0x11, 0x98, 0xE0 },
      { 0x37, 0x5B, 0x59, 0x48, 0x62, 0x0C },
      { 0x0F, 0x79, 0xD5, 0xB0, 0x50, 0x88 },
      { 0x1F, 0x6D, 0xDD, 0x80, 0x12, 0x23 },
      { 0x5F, 0x65, 0xA9, 0x96, 0x2A, 0x20 },
      { 0xDB, 0x8D, 0xAD, 0x30, 0x0B, 0x50 },
      { 0xD9, 0xAA, 0x8F, 0x11, 0xA0, 0x12 },
      { 0x31, 0xBE, 0xAE, 0x65, 0x24, 0x00 },
      { 0xF0, 0xBE, 0x8C, 0x12, 0x92, 0x81 }
    };
    byte block[] = { 0x73, 0xF6, 0xCB, 0x51, 0x94, 0x27, 0xA6, 0xAC };
    byte expected[] = { 0xB3, 0xEB, 0xA2, 0x74, 0x05, 0xA1, 0x42, 0x80 };

    encryptBlock( block, K );
    TestCase( cmpBytes( block, expected, sizeof( block ) ) );
  }

  ////////////////////////////////////////////////////////////////////////
  // Test decryptBlock()

  {
    // This should match the middle block decryption in test 01
    byte K[ ROUND_COUNT ][ SUBKEY_BYTES ] = {
      {}, // First element not used.
      { 0xF0, 0x3C, 0xE6, 0x28, 0x20, 0x4E },
      { 0x50, 0xBE, 0x76, 0x52, 0x05, 0x21 },
      { 0xE4, 0xFC, 0x76, 0x0A, 0x29, 0x08 },
      { 0xE6, 0xE7, 0x66, 0x60, 0x71, 0x10 },
      { 0xEA, 0xD7, 0x33, 0x61, 0x00, 0x2A },
      { 0xED, 0x93, 0x7B, 0xC4, 0x18, 0x0A },
      { 0xA7, 0xD2, 0xDB, 0x04, 0x12, 0x7C },
      { 0x3F, 0x5B, 0xD2, 0x11, 0x98, 0xE0 },
      { 0x37, 0x5B, 0x59, 0x48, 0x62, 0x0C },
      { 0x0F, 0x79, 0xD5, 0xB0, 0x50, 0x88 },
      { 0x1F, 0x6D, 0xDD, 0x80, 0x12, 0x23 },
      { 0x5F, 0x65, 0xA9, 0x96, 0x2A, 0x20 },
      { 0xDB, 0x8D, 0xAD, 0x30, 0x0B, 0x50 },
      { 0xD9, 0xAA, 0x8F, 0x11, 0xA0, 0x12 },
      { 0x31, 0xBE, 0xAE, 0x65, 0x24, 0x00 },
      { 0xF0, 0xBE, 0x8C, 0x12, 0x92, 0x81 }
    };
    byte block[] = { 0xB3, 0xEB, 0xA2, 0x74, 0x05, 0xA1, 0x42, 0x80 };
    byte expected[] = { 0x73, 0xF6, 0xCB, 0x51, 0x94, 0x27, 0xA6, 0xAC };

    decryptBlock( block, K );
    TestCase( cmpBytes( block, expected, sizeof( block ) ) );
  }

  {
    // This should match the first block decryption in test 11
    byte K[ ROUND_COUNT ][ SUBKEY_BYTES ] = {
      {}, // First element not used.
      { 0xE0, 0x3E, 0x06, 0x18, 0x69, 0x63 },
      { 0x60, 0x36, 0x26, 0x64, 0x49, 0x25 },
      { 0xE0, 0x94, 0x74, 0x82, 0x08, 0xDA },
      { 0xC4, 0xC2, 0x72, 0xC5, 0x93, 0x11 },
      { 0xA6, 0xD3, 0x32, 0x13, 0x06, 0x68 },
      { 0xAE, 0x13, 0x43, 0x58, 0x99, 0x04 },
      { 0x2B, 0x52, 0x59, 0x00, 0x64, 0xBC },
      { 0x0D, 0x51, 0xD8, 0x69, 0x38, 0x81 },
      { 0x17, 0x41, 0xD8, 0x2A, 0xA2, 0x31 },
      { 0x1E, 0x49, 0x91, 0xB3, 0x4D, 0x02 },
      { 0x1F, 0x29, 0x0D, 0x0C, 0x03, 0x12 },
      { 0x0B, 0x24, 0x8D, 0xD5, 0x60, 0x44 },
      { 0x59, 0x0C, 0xAC, 0x60, 0x82, 0xC8 },
      { 0xD0, 0xA8, 0xA8, 0x90, 0xB4, 0x0F },
      { 0x90, 0xAE, 0x26, 0x2E, 0x16, 0xA0 },
      { 0xB0, 0xAE, 0x06, 0x0A, 0x70, 0xA2 }
    };
    byte block[] = { 0x35, 0x80, 0x10, 0x52, 0x02, 0x61, 0x46, 0x5E };
    byte expected[] = { 0x73, 0xF6, 0xCB, 0x51, 0x94, 0x27, 0xA6, 0xAC };

    decryptBlock( block, K );
    TestCase( cmpBytes( block, expected, sizeof( block ) ) );
  }

  {
    // This should match the last block decryption in test 11
    byte K[ ROUND_COUNT ][ SUBKEY_BYTES ] = {
      {}, // First element not used.
      { 0xD0, 0xB6, 0x66, 0x56, 0x0C, 0x29 },
      { 0xE0, 0xAE, 0x76, 0x20, 0xD4, 0x16 },
      { 0xE4, 0xF6, 0x32, 0xCD, 0x04, 0xA2 },
      { 0xE6, 0x97, 0x72, 0x8C, 0x4A, 0x49 },
      { 0xEE, 0xD2, 0x53, 0x12, 0xD2, 0x54 },
      { 0x2F, 0xD3, 0x5A, 0x91, 0x85, 0xA0 },
      { 0x2E, 0x51, 0xDB, 0x88, 0x2E, 0x01 },
      { 0x3F, 0x49, 0x59, 0x7A, 0x62, 0x14 },
      { 0x1F, 0x59, 0xD9, 0x82, 0x88, 0x27 },
      { 0x1F, 0x61, 0xCD, 0x06, 0x2F, 0x94 },
      { 0x1B, 0x4D, 0x8D, 0x39, 0x01, 0xD1 },
      { 0x59, 0x29, 0xAD, 0x43, 0xC0, 0x03 },
      { 0x91, 0xAC, 0xAD, 0x46, 0x25, 0x0C },
      { 0xD1, 0x2E, 0xA6, 0xA8, 0x11, 0xCC },
      { 0xF0, 0xBE, 0xA4, 0x40, 0xD2, 0xA3 },
      { 0xE0, 0xBC, 0x26, 0x28, 0xE9, 0x48 }
    };
    byte block[] = { 0xB3, 0xEB, 0xA2, 0x74, 0x05, 0xA1, 0x42, 0x80 };
    byte expected[] = { 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x0A, 0x01 };

    decryptBlock( block, K );
    TestCase( cmpBytes( block, expected, sizeof( block ) ) );
  }

  ////////////////////////////////////////////////////////////////////////
  // Test encryptTDES()

  {
    // This should match the input and key for test 01
    byte buffer[] = { 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x0A };
    byte key[] = { 0x54, 0x68, 0x69, 0x73, 0x20, 0x6B, 0x65, 0x79,
      0x20, 0x69, 0x73, 0x20, 0x6A, 0x75, 0x73, 0x74,
      0x20, 0x61, 0x73, 0x63, 0x69, 0x69, 0x2E, 0x0A };
    byte expected[] = { 0x35, 0x80, 0x10, 0x52, 0x02, 0x61, 0x46, 0x5E };

    int n;
    byte *result = encryptTDES( buffer, sizeof( buffer ), key, sizeof( key ), &n );
    TestCase( n == sizeof( expected ) );
    TestCase( cmpBytes( result, expected, sizeof( expected ) ) );
    free( result );
  }

  {
    // This should match the input and key for test 03
    byte buffer[] = { 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x70,
      0x75, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6C, 0x6F,
      0x6E, 0x67, 0x65, 0x72, 0x2E, 0x0A, 0x49, 0x74,
      0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65,
      0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x31, 0x30,
      0x0A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x73, 0x20,
      0x77, 0x69, 0x74, 0x68, 0x20, 0x37, 0x20, 0x62,
      0x79, 0x74, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x0A,
      0x70, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x2E,
      0x0A };
    byte key[] = { 0x73, 0x75, 0x70, 0x65, 0x72, 0x0A, 0x73, 0x65,
      0x63, 0x72, 0x65, 0x74, 0x0A, 0x63, 0x72, 0x79,
      0x70, 0x74, 0x6F, 0x0A, 0x6B, 0x65, 0x79, 0x0A };
    byte expected[] = { 0xBD, 0xE8, 0x47, 0x6E, 0xA8, 0xB3, 0x9F, 0x98,
      0x77, 0xA3, 0x96, 0x88, 0xFE, 0x4B, 0xA4, 0x98,
      0xD5, 0x40, 0xE9, 0xC6, 0x48, 0x76, 0x1E, 0x7E,
      0x50, 0xEA, 0x41, 0xD4, 0x6E, 0x9A, 0x66, 0x04,
      0x6B, 0xD0, 0xC5, 0xA0, 0x46, 0x68, 0x84, 0x14,
      0x36, 0xF8, 0x2C, 0xB4, 0x19, 0xAC, 0xA7, 0x7E,
      0xA3, 0x93, 0x47, 0xB8, 0xF1, 0x80, 0x3E, 0x42,
      0x67, 0x40, 0x31, 0x8A, 0xE6, 0xB4, 0x2B, 0x84,
      0x87, 0x8A, 0x40, 0xF0, 0x20, 0xA1, 0x5A, 0x6C,
      0x96, 0xB3, 0x28, 0xFC, 0xCC, 0x66, 0x62, 0x50 };

    int n;
    byte *result = encryptTDES( buffer, sizeof( buffer ), key, sizeof( key ), &n );
    TestCase( n == sizeof( expected ) );
    TestCase( cmpBytes( result, expected, sizeof( expected ) ) );
    free( result );
  }
  
  ////////////////////////////////////////////////////////////////////////
  // Test decryptTDES()

  {
    // This should match the input and key for test 11
    byte buffer[] = { 0x35, 0x80, 0x10, 0x52, 0x02, 0x61, 0x46, 0x5E };
    byte key[] = { 0x54, 0x68, 0x69, 0x73, 0x20, 0x6B, 0x65, 0x79,
      0x20, 0x69, 0x73, 0x20, 0x6A, 0x75, 0x73, 0x74,
      0x20, 0x61, 0x73, 0x63, 0x69, 0x69, 0x2E, 0x0A };
    byte expected[] = { 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x0A };

    int n;
    byte *result = decryptTDES( buffer, sizeof( buffer ), key, sizeof( key ), &n );
    TestCase( n == sizeof( expected ) );
    TestCase( cmpBytes( result, expected, sizeof( expected ) ) );
    free( result );
  }

  {
    // This should match the input and key for test 23
    byte buffer[] = { 0xBD, 0xE8, 0x47, 0x6E, 0xA8, 0xB3, 0x9F, 0x98,
      0x77, 0xA3, 0x96, 0x88, 0xFE, 0x4B, 0xA4, 0x98,
      0xD5, 0x40, 0xE9, 0xC6, 0x48, 0x76, 0x1E, 0x7E,
      0x50, 0xEA, 0x41, 0xD4, 0x6E, 0x9A, 0x66, 0x04,
      0x6B, 0xD0, 0xC5, 0xA0, 0x46, 0x68, 0x84, 0x14,
      0x36, 0xF8, 0x2C, 0xB4, 0x19, 0xAC, 0xA7, 0x7E,
      0xA3, 0x93, 0x47, 0xB8, 0xF1, 0x80, 0x3E, 0x42,
      0x67, 0x40, 0x31, 0x8A, 0xE6, 0xB4, 0x2B, 0x84,
      0x87, 0x8A, 0x40, 0xF0, 0x20, 0xA1, 0x5A, 0x6C,
      0x96, 0xB3, 0x28, 0xFC, 0xCC, 0x66, 0x62, 0x50 };
    byte key[] = { 0x73, 0x75, 0x70, 0x65, 0x72, 0x0A, 0x73, 0x65,
      0x63, 0x72, 0x65, 0x74, 0x0A, 0x63, 0x72, 0x79,
      0x70, 0x74, 0x6F, 0x0A, 0x6B, 0x65, 0x79, 0x0A };
    byte expected[] = { 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x70,
      0x75, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6C, 0x6F,
      0x6E, 0x67, 0x65, 0x72, 0x2E, 0x0A, 0x49, 0x74,
      0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65,
      0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x31, 0x30,
      0x0A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x73, 0x20,
      0x77, 0x69, 0x74, 0x68, 0x20, 0x37, 0x20, 0x62,
      0x79, 0x74, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x0A,
      0x70, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x2E,
      0x0A };

    int n;
    byte *result = decryptTDES( buffer, sizeof( buffer ), key, sizeof( key ), &n );
    TestCase( n == sizeof( expected ) );
    TestCase( cmpBytes( result, expected, sizeof( expected ) ) );
    free( result );
  }

  // Once you move the #ifdef DISABLE_TESTS to here, you've enabled
  // all the tests.
  
  // Report a message if some tests are still disabled.
  if ( totalTests < EXPECTED_TOTAL )
    printf( "** %d of %d tests currently enabled.\n", totalTests,
            EXPECTED_TOTAL );
  if ( totalTests > EXPECTED_TOTAL )
    printf( "** There were more passing unit tests than expected (%d vs %d).\n",
            totalTests, EXPECTED_TOTAL );

  // Exit successfully if all tests are enabled and they all pass.
  if ( passedTests != EXPECTED_TOTAL )
    return EXIT_FAILURE;
  else
    return EXIT_SUCCESS;
}
